{"ts":1381265817143,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * WP_Theme Class\n *\n * @package WordPress\n * @subpackage Theme\n */\n\nfinal class WP_Theme implements ArrayAccess {\n\n\t/**\n\t * Headers for style.css files.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $file_headers = array(\n\t\t'Name'        => 'Theme Name',\n\t\t'ThemeURI'    => 'Theme URI',\n\t\t'Description' => 'Description',\n\t\t'Author'      => 'Author',\n\t\t'AuthorURI'   => 'Author URI',\n\t\t'Version'     => 'Version',\n\t\t'Template'    => 'Template',\n\t\t'Status'      => 'Status',\n\t\t'Tags'        => 'Tags',\n\t\t'TextDomain'  => 'Text Domain',\n\t\t'DomainPath'  => 'Domain Path',\n\t);\n\n\t/**\n\t * Default themes.\n\t *\n\t * @static\n\t * @access private\n\t * @var array\n\t */\n\tprivate static $default_themes = array(\n\t\t'classic'        => 'WordPress Classic',\n\t\t'default'        => 'WordPress Default',\n\t\t'twentyten'      => 'Twenty Ten',\n\t\t'twentyeleven'   => 'Twenty Eleven',\n\t\t'twentytwelve'   => 'Twenty Twelve',\n\t\t'twentythirteen' => 'Twenty Thirteen',\n\t);\n\n\t/**\n\t * Absolute path to the theme root, usually wp-content/themes\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $theme_root;\n\n\t/**\n\t * Header data from the theme's style.css file.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers = array();\n\n\t/**\n\t * Header data from the theme's style.css file after being sanitized.\n\t *\n\t * @access private\n\t * @var array\n\t */\n\tprivate $headers_sanitized;\n\n\t/**\n\t * Header name from the theme's style.css after being translated.\n\t *\n\t * Cached due to sorting functions running over the translated name.\n\t */\n\tprivate $name_translated;\n\n\t/**\n\t * Errors encountered when initializing the theme.\n\t *\n\t * @access private\n\t * @var WP_Error\n\t */\n\tprivate $errors;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, 'stylesheet' is the same as 'template'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $stylesheet;\n\n\t/**\n\t * The directory name of the theme's files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, 'template' is the same as 'stylesheet'.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $template;\n\n\t/**\n\t * A reference to the parent theme, in the case of a child theme.\n\t *\n\t * @access private\n\t * @var WP_Theme\n\t */\n\tprivate $parent;\n\n\t/**\n\t * URL to the theme root, usually an absolute URL to wp-content/themes\n\t *\n\t * @access private\n\t * var string\n\t */\n\tprivate $theme_root_uri;\n\n\t/**\n\t * Flag for whether the theme's textdomain is loaded.\n\t *\n\t * @access private\n\t * @var bool\n\t */\n\tprivate $textdomain_loaded;\n\n\t/**\n\t * Stores an md5 hash of the theme root, to function as the cache key.\n\t *\n\t * @access private\n\t * @var string\n\t */\n\tprivate $cache_hash;\n\n\t/**\n\t * Flag for whether the themes cache bucket should be persistently cached.\n\t *\n\t * Default is false. Can be set with the wp_cache_themes_persistently filter.\n\t *\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $persistently_cache;\n\n\t/**\n\t * Expiration time for the themes cache bucket.\n\t *\n\t * By default the bucket is not cached, so this value is useless.\n\t *\n\t * @access private\n\t * @var bool\n\t */\n\tprivate static $cache_expiration = 1800;\n\n\t/**\n\t * Constructor for WP_Theme.\n\t *\n\t * @param string $theme_dir Directory of the theme within the theme_root.\n\t * @param string $theme_root Theme root.\n\t * @param WP_Error|null $_child If this theme is a parent theme, the child may be passed for validation purposes.\n\t */\n\tpublic function __construct( $theme_dir, $theme_root, $_child = null ) {\n\t\tglobal $wp_theme_directories;\n\n\t\t// Initialize caching on first run.\n\t\tif ( ! isset( self::$persistently_cache ) ) {\n\t\t\tself::$persistently_cache = apply_filters( 'wp_cache_themes_persistently', false, 'WP_Theme' );\n\t\t\tif ( self::$persistently_cache ) {\n\t\t\t\twp_cache_add_global_groups( 'themes' );\n\t\t\t\tif ( is_int( self::$persistently_cache ) )\n\t\t\t\t\tself::$cache_expiration = self::$persistently_cache;\n\t\t\t} else {\n\t\t\t\twp_cache_add_non_persistent_groups( 'themes' );\n\t\t\t}\n\t\t}\n\n\t\t$this->theme_root = $theme_root;\n\t\t$this->stylesheet = $theme_dir;\n\n\t\t// Correct a situation where the theme is 'some-directory/some-theme' but 'some-directory' was passed in as part of the theme root instead.\n\t\tif ( ! in_array( $theme_root, (array) $wp_theme_directories ) && in_array( dirname( $theme_root ), (array) $wp_theme_directories ) ) {\n\t\t\t$this->stylesheet = basename( $this->theme_root ) . '/' . $this->stylesheet;\n\t\t\t$this->theme_root = dirname( $theme_root );\n\t\t}\n\n\t\t$this->cache_hash = md5( $this->theme_root . '/' . $this->stylesheet );\n\t\t$theme_file = $this->stylesheet . '/style.css';\n\n\t\t$cache = $this->cache_get( 'theme' );\n\n\t\tif ( is_array( $cache ) ) {\n\t\t\tforeach ( array( 'errors', 'headers', 'template' ) as $key ) {\n\t\t\t\tif ( isset( $cache[ $key ] ) )\n\t\t\t\t\t$this->$key = $cache[ $key ];\n\t\t\t}\n\t\t\tif ( $this->errors )\n\t\t\t\treturn;\n\t\t\tif ( isset( $cache['theme_root_template'] ) )\n\t\t\t\t$theme_root_template = $cache['theme_root_template'];\n\t\t} elseif ( ! file_exists( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet ) )\n\t\t\t\t$this->errors = new WP_Error( 'theme_not_found', __( 'The theme directory does not exist.' ) );\n\t\t\telse\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_stylesheet', __( 'Stylesheet is missing.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\tif ( ! file_exists( $this->theme_root ) ) // Don't cache this one.\n\t\t\t\t$this->errors->add( 'theme_root_missing', __( 'ERROR: The themes directory is either empty or doesn&#8217;t exist. Please check your installation.' ) );\n\t\t\treturn;\n\t\t} elseif ( ! is_readable( $this->theme_root . '/' . $theme_file ) ) {\n\t\t\t$this->headers['Name'] = $this->stylesheet;\n\t\t\t$this->errors = new WP_Error( 'theme_stylesheet_not_readable', __( 'Stylesheet is not readable.' ) );\n\t\t\t$this->template = $this->stylesheet;\n\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\treturn;\n\t\t} else {\n\t\t\t$this->headers = get_file_data( $this->theme_root . '/' . $theme_file, self::$file_headers, 'theme' );\n\t\t\t// Default themes always trump their pretenders.\n\t\t\t// Properly identify default themes that are inside a directory within wp-content/themes.\n\t\t\tif ( $default_theme_slug = array_search( $this->headers['Name'], self::$default_themes ) ) {\n\t\t\t\tif ( basename( $this->stylesheet ) != $default_theme_slug )\n\t\t\t\t\t$this->headers['Name'] .= '/' . $this->stylesheet;\n\t\t\t}\n\t\t}\n\n\t\t// (If template is set from cache [and there are no errors], we know it's good.)\n\t\tif ( ! $this->template && ! ( $this->template = $this->headers['Template'] ) ) {\n\t\t\t$this->template = $this->stylesheet;\n\t\t\tif ( ! file_exists( $this->theme_root . '/' . $this->stylesheet . '/index.php' ) ) {\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_index', __( 'Template is missing.' ) );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If we got our data from cache, we can assume that 'template' is pointing to the right place.\n\t\tif ( ! is_array( $cache ) && $this->template != $this->stylesheet && ! file_exists( $this->theme_root . '/' . $this->template . '/index.php' ) ) {\n\t\t\t// If we're in a directory of themes inside /themes, look for the parent nearby.\n\t\t\t// wp-content/themes/directory-of-themes/*\n\t\t\t$parent_dir = dirname( $this->stylesheet );\n\t\t\tif ( '.' != $parent_dir && file_exists( $this->theme_root . '/' . $parent_dir . '/' . $this->template . '/index.php' ) ) {\n\t\t\t\t$this->template = $parent_dir . '/' . $this->template;\n\t\t\t} elseif ( ( $directories = search_theme_directories() ) && isset( $directories[ $this->template ] ) ) {\n\t\t\t\t// Look for the template in the search_theme_directories() results, in case it is in another theme root.\n\t\t\t\t// We don't look into directories of themes, just the theme root.\n\t\t\t\t$theme_root_template = $directories[ $this->template ]['theme_root'];\n\t\t\t} else {\n\t\t\t\t// Parent theme is missing.\n\t\t\t\t$this->errors = new WP_Error( 'theme_no_parent', sprintf( __( 'The parent theme is missing. Please install the \"%s\" parent theme.' ), $this->template ) );\n\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t$this->parent = new WP_Theme( $this->template, $this->theme_root, $this );\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Set the parent, if we're a child theme.\n\t\tif ( $this->template != $this->stylesheet ) {\n\t\t\t// If we are a parent, then there is a problem. Only two generations allowed! Cancel things out.\n\t\t\tif ( is_a( $_child, 'WP_Theme' ) && $_child->template == $this->stylesheet ) {\n\t\t\t\t$_child->parent = null;\n\t\t\t\t$_child->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), $_child->template ) );\n\t\t\t\t$_child->cache_add( 'theme', array( 'headers' => $_child->headers, 'errors' => $_child->errors, 'stylesheet' => $_child->stylesheet, 'template' => $_child->template ) );\n\t\t\t\t// The two themes actually reference each other with the Template header.\n\t\t\t\tif ( $_child->stylesheet == $this->template ) {\n\t\t\t\t\t$this->errors = new WP_Error( 'theme_parent_invalid', sprintf( __( 'The \"%s\" theme is not a valid parent theme.' ), $this->template ) );\n\t\t\t\t\t$this->cache_add( 'theme', array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template ) );\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Set the parent. Pass the current instance so we can do the crazy checks above and assess errors.\n\t\t\t$this->parent = new WP_Theme( $this->template, isset( $theme_root_template ) ? $theme_root_template : $this->theme_root, $this );\n\t\t}\n\n\t\t// We're good. If we didn't retrieve from cache, set it.\n\t\tif ( ! is_array( $cache ) ) {\n\t\t\t$cache = array( 'headers' => $this->headers, 'errors' => $this->errors, 'stylesheet' => $this->stylesheet, 'template' => $this->template );\n\t\t\t// If the parent theme is in another root, we'll want to cache this. Avoids an entire branch of filesystem calls above.\n\t\t\tif ( isset( $theme_root_template ) )\n\t\t\t\t$cache['theme_root_template'] = $theme_root_template;\n\t\t\t$this->cache_add( 'theme', $cache );\n\t\t}\n\t}\n\n\t/**\n\t * When converting the object to a string, the theme name is returned.\n\t *\n\t * @return string Theme name, ready for display (translated)\n\t */\n\tpublic function __toString() {\n\t\treturn (string) $this->display('Name');\n\t}\n\n\t/**\n\t * __isset() magic method for properties formerly returned by current_theme_info()\n\t */\n\tpublic function __isset( $offset ) {\n\t\tstatic $properties = array(\n\t\t\t'name', 'title', 'version', 'parent_theme', 'template_dir', 'stylesheet_dir', 'template', 'stylesheet',\n\t\t\t'screenshot', 'description', 'author', 'tags', 'theme_root', 'theme_root_uri',\n\t\t);\n\n\t\treturn in_array( $offset, $properties );\n\t}\n\n\t/**\n\t * __get() magic method for properties formerly returned by current_theme_info()\n\t */\n\tpublic function __get( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'name' :\n\t\t\tcase 'title' :\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'version' :\n\t\t\t\treturn $this->get('Version');\n\t\t\tcase 'parent_theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tcase 'template_dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'stylesheet_dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\t// 'author' and 'description' did not previously return translated data.\n\t\t\tcase 'description' :\n\t\t\t\treturn $this->display('Description');\n\t\t\tcase 'author' :\n\t\t\t\treturn $this->display('Author');\n\t\t\tcase 'tags' :\n\t\t\t\treturn $this->get( 'Tags' );\n\t\t\tcase 'theme_root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'theme_root_uri' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\t// For cases where the array was converted to an object.\n\t\t\tdefault :\n\t\t\t\treturn $this->offsetGet( $offset );\n\t\t}\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t */\n\tpublic function offsetSet( $offset, $value ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t */\n\tpublic function offsetUnset( $offset ) {}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes()\n\t */\n\tpublic function offsetExists( $offset ) {\n\t\tstatic $keys = array(\n\t\t\t'Name', 'Version', 'Status', 'Title', 'Author', 'Author Name', 'Author URI', 'Description',\n\t\t\t'Template', 'Stylesheet', 'Template Files', 'Stylesheet Files', 'Template Dir', 'Stylesheet Dir',\n\t\t\t 'Screenshot', 'Tags', 'Theme Root', 'Theme Root URI', 'Parent Theme',\n\t\t);\n\n\t\treturn in_array( $offset, $keys );\n\t}\n\n\t/**\n\t * Method to implement ArrayAccess for keys formerly returned by get_themes().\n\t *\n\t * Author, Author Name, Author URI, and Description did not previously return\n\t * translated data. We are doing so now as it is safe to do. However, as\n\t * Name and Title could have been used as the key for get_themes(), both remain\n\t * untranslated for back compatibility. This means that ['Name'] is not ideal,\n\t * and care should be taken to use $theme->display('Name') to get a properly\n\t * translated header.\n\t */\n\tpublic function offsetGet( $offset ) {\n\t\tswitch ( $offset ) {\n\t\t\tcase 'Name' :\n\t\t\tcase 'Title' :\n\t\t\t\t// See note above about using translated data. get() is not ideal.\n\t\t\t\t// It is only for backwards compatibility. Use display().\n\t\t\t\treturn $this->get('Name');\n\t\t\tcase 'Author' :\n\t\t\t\treturn $this->display( 'Author');\n\t\t\tcase 'Author Name' :\n\t\t\t\treturn $this->display( 'Author', false);\n\t\t\tcase 'Author URI' :\n\t\t\t\treturn $this->display('AuthorURI');\n\t\t\tcase 'Description' :\n\t\t\t\treturn $this->display( 'Description');\n\t\t\tcase 'Version' :\n\t\t\tcase 'Status' :\n\t\t\t\treturn $this->get( $offset );\n\t\t\tcase 'Template' :\n\t\t\t\treturn $this->get_template();\n\t\t\tcase 'Stylesheet' :\n\t\t\t\treturn $this->get_stylesheet();\n\t\t\tcase 'Template Files' :\n\t\t\t\treturn $this->get_files( 'php', 1, true );\n\t\t\tcase 'Stylesheet Files' :\n\t\t\t\treturn $this->get_files( 'css', 0, false );\n\t\t\tcase 'Template Dir' :\n\t\t\t\treturn $this->get_template_directory();\n\t\t\tcase 'Stylesheet Dir' :\n\t\t\t\treturn $this->get_stylesheet_directory();\n\t\t\tcase 'Screenshot' :\n\t\t\t\treturn $this->get_screenshot( 'relative' );\n\t\t\tcase 'Tags' :\n\t\t\t\treturn $this->get('Tags');\n\t\t\tcase 'Theme Root' :\n\t\t\t\treturn $this->get_theme_root();\n\t\t\tcase 'Theme Root URI' :\n\t\t\t\treturn $this->get_theme_root_uri();\n\t\t\tcase 'Parent Theme' :\n\t\t\t\treturn $this->parent() ? $this->parent()->get('Name') : '';\n\t\t\tdefault :\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Returns errors property.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Error|bool WP_Error if there are errors, or false.\n\t */\n\tpublic function errors() {\n\t\treturn is_wp_error( $this->errors ) ? $this->errors : false;\n\t}\n\n\t/**\n\t * Whether the theme exists.\n\t *\n\t * A theme with errors exists. A theme with the error of 'theme_not_found',\n\t * meaning that the theme's directory was not found, does not exist.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return bool Whether the theme exists.\n\t */\n\tpublic function exists() {\n\t\treturn ! ( $this->errors() && in_array( 'theme_not_found', $this->errors()->get_error_codes() ) );\n\t}\n\n\t/**\n\t * Returns reference to the parent theme.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return WP_Theme|bool Parent theme, or false if the current theme is not a child theme.\n\t */\n\tpublic function parent() {\n\t\treturn isset( $this->parent ) ? $this->parent : false;\n\t}\n\n\t/**\n\t * Adds theme data to cache.\n\t *\n\t * Cache entries keyed by the theme and the type of data.\n\t *\n\t * @access private\n\t * @since 3.4.0\n\t *\n\t * @param string $key Type of data to store (theme, screenshot, headers, page_templates)\n\t * @param string $data Data to store\n\t * @return bool Return value from wp_cache_add()\n\t */\n\tprivate function cache_add( $key, $data ) {\n\t\treturn wp_cache_add( $key . '-' . $this->cache_hash, $data, 'themes', self::$cache_expiration );\n\t}\n\n\t/**\n\t * Gets theme data from cache.\n\t *\n\t * Cache entries are keyed by the theme and the type of data.\n\t *\n\t * @access private\n\t * @since 3.4.0\n\t *\n\t * @param string $key Type of data to retrieve (theme, screenshot, headers, page_templates)\n\t * @return mixed Retrieved data\n\t */\n\tprivate function cache_get( $key ) {\n\t\treturn wp_cache_get( $key . '-' . $this->cache_hash, 'themes' );\n\t}\n\n\t/**\n\t * Clears the cache for the theme.\n\t *\n\t * @access public\n\t * @since 3.4.0\n\t */\n\tpublic function cache_delete() {\n\t\tforeach ( array( 'theme', 'screenshot', 'headers', 'page_templates' ) as $key )\n\t\t\twp_cache_delete( $key . '-' . $this->cache_hash, 'themes' );\n\t\t$this->template = $this->textdomain_loaded = $this->theme_root_uri = $this->parent = $this->errors = $this->headers_sanitized = $this->name_translated = null;\n\t\t$this->headers = array();\n\t\t$this->__construct( $this->stylesheet, $this->theme_root );\n\t}\n\n\t/**\n\t * Get a raw, unformatted theme header.\n\t *\n\t * The header is sanitized, but is not translated, and is not marked up for display.\n\t * To get a theme header for display, use the display() method.\n\t *\n\t * Use the get_template() method, not the 'Template' header, for finding the template.\n\t * The 'Template' header is only good for what was written in the style.css, while\n\t * get_template() takes into account where WordPress actually located the theme and\n\t * whether it is actually valid.\n\t *\n\t * @access public\n\t * @since 3.4.0\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @return string String on success, false on failure.\n\t */\n\tpublic function get( $header ) {\n\t\tif ( ! isset( $this->headers[ $header ] ) )\n\t\t\treturn false;\n\n\t\tif ( ! isset( $this->headers_sanitized ) ) {\n\t\t\t$this->headers_sanitized = $this->cache_get( 'headers' );\n\t\t\tif ( ! is_array( $this->headers_sanitized ) )\n\t\t\t\t$this->headers_sanitized = array();\n\t\t}\n\n\t\tif ( isset( $this->headers_sanitized[ $header ] ) )\n\t\t\treturn $this->headers_sanitized[ $header ];\n\n\t\t// If themes are a persistent group, sanitize everything and cache it. One cache add is better than many cache sets.\n\t\tif ( self::$persistently_cache ) {\n\t\t\tforeach ( array_keys( $this->headers ) as $_header )\n\t\t\t\t$this->headers_sanitized[ $_header ] = $this->sanitize_header( $_header, $this->headers[ $_header ] );\n\t\t\t$this->cache_add( 'headers', $this->headers_sanitized );\n\t\t} else {\n\t\t\t$this->headers_sanitized[ $header ] = $this->sanitize_header( $header, $this->headers[ $header ] );\n\t\t}\n\n\t\treturn $this->headers_sanitized[ $header ];\n\t}\n\n\t/**\n\t * Gets a theme header, formatted and translated for display.\n\t *\n\t * @access public\n\t * @since 3.4.0\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param bool $markup Optional. Whether to mark up the header. Defaults to true.\n\t * @param bool $translate Optional. Whether to translate the header. Defaults to true.\n\t * @return string Processed header, false on failure.\n\t */\n\tpublic function display( $header, $markup = true, $translate = true ) {\n\t\t$value = $this->get( $header );\n\n\t\tif ( $translate && ( empty( $value ) || ! $this->load_textdomain() ) )\n\t\t\t$translate = false;\n\n\t\tif ( $translate )\n\t\t\t$value = $this->translate_header( $header, $value );\n\n\t\tif ( $markup )\n\t\t\t$value = $this->markup_header( $header, $value, $translate );\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Sanitize a theme header.\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to sanitize.\n\t */\n\tprivate function sanitize_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Status' :\n\t\t\t\tif ( ! $value ) {\n\t\t\t\t\t$value = 'publish';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Fall through otherwise.\n\t\t\tcase 'Name' :\n\t\t\t\tstatic $header_tags = array(\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\t// There shouldn't be anchor tags in Author, but some themes like to be challenging.\n\t\t\tcase 'Description' :\n\t\t\t\tstatic $header_tags_with_a = array(\n\t\t\t\t\t'a'       => array( 'href' => true, 'title' => true ),\n\t\t\t\t\t'abbr'    => array( 'title' => true ),\n\t\t\t\t\t'acronym' => array( 'title' => true ),\n\t\t\t\t\t'code'    => true,\n\t\t\t\t\t'em'      => true,\n\t\t\t\t\t'strong'  => true,\n\t\t\t\t);\n\t\t\t\t$value = wp_kses( $value, $header_tags_with_a );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url_raw( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\t$value = array_filter( array_map( 'trim', explode( ',', strip_tags( $value ) ) ) );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Mark up a theme header.\n\t *\n\t * @access private\n\t * @since 3.4.0\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to mark up.\n\t * @param string $translate Whether the header has been translated.\n\t * @return string Value, marked up.\n\t */\n\tprivate function markup_header( $header, $value, $translate ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\tif ( empty( $value ) )\n\t\t\t\t\t$value = $this->get_stylesheet();\n\t\t\t\tbreak;\n\t\t\tcase 'Description' :\n\t\t\t\t$value = wptexturize( $value );\n\t\t\t\tbreak;\n\t\t\tcase 'Author' :\n\t\t\t\tif ( $this->get('AuthorURI') ) {\n\t\t\t\t\tstatic $attr = null;\n\t\t\t\t\tif ( ! isset( $attr ) )\n\t\t\t\t\t\t$attr = esc_attr__( 'Visit author homepage' );\n\t\t\t\t\t$value = sprintf( '<a href=\"%1$s\" title=\"%2$s\">%3$s</a>', $this->display( 'AuthorURI', true, $translate ), $attr, $value );\n\t\t\t\t} elseif ( ! $value ) {\n\t\t\t\t\t$value = __( 'Anonymous' );\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'Tags' :\n\t\t\t\tstatic $comma = null;\n\t\t\t\tif ( ! isset( $comma ) ) {\n\t\t\t\t\t/* translators: used between list items, there is a space after the comma */\n\t\t\t\t\t$comma = __( ', ' );\n\t\t\t\t}\n\t\t\t\t$value = implode( $comma, $value );\n\t\t\t\tbreak;\n\t\t\tcase 'ThemeURI' :\n\t\t\tcase 'AuthorURI' :\n\t\t\t\t$value = esc_url( $value );\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn $value;\n\t}\n\n\t/**\n\t * Translate a theme header.\n\t *\n\t * @access private\n\t * @since 3.4.0\n\t *\n\t * @param string $header Theme header. Name, Description, Author, Version, ThemeURI, AuthorURI, Status, Tags.\n\t * @param string $value Value to translate.\n\t * @return string Translated value.\n\t */\n\tprivate function translate_header( $header, $value ) {\n\t\tswitch ( $header ) {\n\t\t\tcase 'Name' :\n\t\t\t\t// Cached for sorting reasons.\n\t\t\t\tif ( isset( $this->name_translated ) )\n\t\t\t\t\treturn $this->name_translated;\n\t\t\t\t$this->name_translated = translate( $value, $this->get('TextDomain' ) );\n\t\t\t\treturn $this->name_translated;\n\t\t\tcase 'Tags' :\n\t\t\t\tif ( empty( $value ) || ! function_exists( 'get_theme_feature_list' ) )\n\t\t\t\t\treturn $value;\n\n\t\t\t\tstatic $tags_list;\n\t\t\t\tif ( ! isset( $tags_list ) ) {\n\t\t\t\t\t$tags_list = array();\n\t\t\t\t\t$feature_list = get_theme_feature_list( false ); // No API\n\t\t\t\t\tforeach ( $feature_list as $tags )\n\t\t\t\t\t\t$tags_list += $tags;\n\t\t\t\t}\n\n\t\t\t\tforeach ( $value as &$tag ) {\n\t\t\t\t\tif ( isset( $tags_list[ $tag ] ) )\n\t\t\t\t\t\t$tag = $tags_list[ $tag ];\n\t\t\t\t}\n\n\t\t\t\treturn $value;\n\t\t\t\tbreak;\n\t\t\tdefault :\n\t\t\t\t$value = translate( $value, $this->get('TextDomain') );\n\t\t}\n\t\treturn $value;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"stylesheet\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is directory name of the child theme.\n\t * Otherwise, get_stylesheet() is the same as get_template().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Stylesheet\n\t */\n\tpublic function get_stylesheet() {\n\t\treturn $this->stylesheet;\n\t}\n\n\t/**\n\t * The directory name of the theme's \"template\" files, inside the theme root.\n\t *\n\t * In the case of a child theme, this is the directory name of the parent theme.\n\t * Otherwise, the get_template() is the same as get_stylesheet().\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Template\n\t */\n\tpublic function get_template() {\n\t\treturn $this->template;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory() {\n\t\tif ( $this->errors() && in_array( 'theme_root_missing', $this->errors()->get_error_codes() ) )\n\t\t\treturn '';\n\n\t\treturn $this->theme_root . '/' . $this->stylesheet;\n\t}\n\n\t/**\n\t * Returns the absolute path to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the absolute path to the directory\n\t * of the parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Absolute path of the template directory.\n\t */\n\tpublic function get_template_directory() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root = $this->parent()->theme_root;\n\t\telse\n\t\t\t$theme_root = $this->theme_root;\n\n\t\treturn $theme_root . '/' . $this->template;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"stylesheet\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * child theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the stylesheet directory.\n\t */\n\tpublic function get_stylesheet_directory_uri() {\n\t\treturn $this->get_theme_root_uri() . '/' . str_replace( '%2F', '/', rawurlencode( $this->stylesheet ) );\n\t}\n\n\t/**\n\t * Returns the URL to the directory of a theme's \"template\" files.\n\t *\n\t * In the case of a child theme, this is the URL to the directory of the\n\t * parent theme's files.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string URL to the template directory.\n\t */\n\tpublic function get_template_directory_uri() {\n\t\tif ( $this->parent() )\n\t\t\t$theme_root_uri = $this->parent()->get_theme_root_uri();\n\t\telse\n\t\t\t$theme_root_uri = $this->get_theme_root_uri();\n\n\t\treturn $theme_root_uri . '/' . str_replace( '%2F', '/', rawurlencode( $this->template ) );\n\t}\n\n\t/**\n\t * The absolute path to the directory of the theme root.\n\t *\n\t * This is typically the absolute path to wp-content/themes.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root.\n\t */\n\tpublic function get_theme_root() {\n\t\treturn $this->theme_root;\n\t}\n\n\t/**\n\t * Returns the URL to the directory of the theme root.\n\t *\n\t * This is typically the absolute URL to wp-content/themes. This forms the basis\n\t * for all other URLs returned by WP_Theme, so we pass it to the public function\n\t * get_theme_root_uri() and allow it to run the theme_root_uri filter.\n\t *\n\t * @uses get_theme_root_uri()\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return string Theme root URI.\n\t */\n\tpublic function get_theme_root_uri() {\n\t\tif ( ! isset( $this->theme_root_uri ) )\n\t\t\t$this->theme_root_uri = get_theme_root_uri( $this->stylesheet, $this->theme_root );\n\t\treturn $this->theme_root_uri;\n\t}\n\n\t/**\n\t * Returns the main screenshot file for the theme.\n\t *\n\t * The main screenshot is called screenshot.png. gif and jpg extensions are also allowed.\n\t *\n\t * Screenshots for a theme must be in the stylesheet directory. (In the case of child\n\t * themes, parent theme screenshots are not inherited.)\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $uri Type of URL to return, either 'relative' or an absolute URI. Defaults to absolute URI.\n\t * @return mixed Screenshot file. False if the theme does not have a screenshot.\n\t */\n\tpublic function get_screenshot( $uri = 'uri' ) {\n\t\t$screenshot = $this->cache_get( 'screenshot' );\n\t\tif ( $screenshot ) {\n\t\t\tif ( 'relative' == $uri )\n\t\t\t\treturn $screenshot;\n\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . $screenshot;\n\t\t} elseif ( 0 === $screenshot ) {\n\t\t\treturn false;\n\t\t}\n\n\t\tforeach ( array( 'png', 'gif', 'jpg', 'jpeg' ) as $ext ) {\n\t\t\tif ( file_exists( $this->get_stylesheet_directory() . \"/screenshot.$ext\" ) ) {\n\t\t\t\t$this->cache_add( 'screenshot', 'screenshot.' . $ext );\n\t\t\t\tif ( 'relative' == $uri )\n\t\t\t\t\treturn 'screenshot.' . $ext;\n\t\t\t\treturn $this->get_stylesheet_directory_uri() . '/' . 'screenshot.' . $ext;\n\t\t\t}\n\t\t}\n\n\t\t$this->cache_add( 'screenshot', 0 );\n\t\treturn false;\n\t}\n\n\t/**\n\t * Return files in the theme's directory.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param mixed $type Optional. Array of extensions to return. Defaults to all files (null).\n\t * @param int $depth Optional. How deep to search for files. Defaults to a flat scan (0 depth). -1 depth is infinite.\n\t * @param bool $search_parent Optional. Whether to return parent files. Defaults to false.\n\t * @return array Array of files, keyed by the path to the file relative to the theme's directory, with the values\n\t * \tbeing absolute paths.\n\t */\n\tpublic function get_files( $type = null, $depth = 0, $search_parent = false ) {\n\t\t$files = (array) self::scandir( $this->get_stylesheet_directory(), $type, $depth );\n\n\t\tif ( $search_parent && $this->parent() )\n\t\t\t$files += (array) self::scandir( $this->get_template_directory(), $type, $depth );\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Returns the theme's page templates.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return array Array of page templates, keyed by filename, with the value of the translated header name.\n\t */\n\tpublic function get_page_templates() {\n\t\t// If you screw up your current theme and we invalidate your parent, most things still work. Let it slide.\n\t\tif ( $this->errors() && $this->errors()->get_error_codes() !== array( 'theme_parent_invalid' ) )\n\t\t\treturn array();\n\n\t\t$page_templates = $this->cache_get( 'page_templates' );\n\n\t\tif ( ! is_array( $page_templates ) ) {\n\t\t\t$page_templates = array();\n\n\t\t\t$files = (array) $this->get_files( 'php', 1 );\n\n\t\t\tforeach ( $files as $file => $full_path ) {\n\t\t\t\tif ( ! preg_match( '|Template Name:(.*)$|mi', file_get_contents( $full_path ), $header ) )\n\t\t\t\t\tcontinue;\n\t\t\t\t$page_templates[ $file ] = _cleanup_header_comment( $header[1] );\n\t\t\t}\n\n\t\t\t$this->cache_add( 'page_templates', $page_templates );\n\t\t}\n\n\t\tif ( $this->load_textdomain() ) {\n\t\t\tforeach ( $page_templates as &$page_template ) {\n\t\t\t\t$page_template = $this->translate_header( 'Template Name', $page_template );\n\t\t\t}\n\t\t}\n\n\t\tif ( $this->parent() )\n\t\t\t$page_templates += $this->parent()->get_page_templates();\n\n\t\treturn $page_templates;\n\t}\n\n\t/**\n\t * Scans a directory for files of a certain extension.\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t *\n\t * @param string $path Absolute path to search.\n\t * @param mixed  Array of extensions to find, string of a single extension, or null for all extensions.\n\t * @param int $depth How deep to search for files. Optional, defaults to a flat scan (0 depth). -1 depth is infinite.\n\t * @param string $relative_path The basename of the absolute path. Used to control the returned path\n\t * \tfor the found files, particularly when this function recurses to lower depths.\n\t */\n\tprivate static function scandir( $path, $extensions = null, $depth = 0, $relative_path = '' ) {\n\t\tif ( ! is_dir( $path ) )\n\t\t\treturn false;\n\n\t\tif ( $extensions ) {\n\t\t\t$extensions = (array) $extensions;\n\t\t\t$_extensions = implode( '|', $extensions );\n\t\t}\n\n\t\t$relative_path = trailingslashit( $relative_path );\n\t\tif ( '/' == $relative_path )\n\t\t\t$relative_path = '';\n\n\t\t$results = scandir( $path );\n\t\t$files = array();\n\n\t\tforeach ( $results as $result ) {\n\t\t\tif ( '.' == $result[0] )\n\t\t\t\tcontinue;\n\t\t\tif ( is_dir( $path . '/' . $result ) ) {\n\t\t\t\tif ( ! $depth || 'CVS' == $result )\n\t\t\t\t\tcontinue;\n\t\t\t\t$found = self::scandir( $path . '/' . $result, $extensions, $depth - 1 , $relative_path . $result );\n\t\t\t\t$files = array_merge_recursive( $files, $found );\n\t\t\t} elseif ( ! $extensions || preg_match( '~\\.(' . $_extensions . ')$~', $result ) ) {\n\t\t\t\t$files[ $relative_path . $result ] = $path . '/' . $result;\n\t\t\t}\n\t\t}\n\n\t\treturn $files;\n\t}\n\n\t/**\n\t * Loads the theme's textdomain.\n\t *\n\t * Translation files are not inherited from the parent theme. Todo: if this fails for the\n\t * child theme, it should probably try to load the parent theme's translations.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return True if the textdomain was successfully loaded or has already been loaded. False if\n\t * \tno textdomain was specified in the file headers, or if the domain could not be loaded.\n\t */\n\tpublic function load_textdomain() {\n\t\tif ( isset( $this->textdomain_loaded ) )\n\t\t\treturn $this->textdomain_loaded;\n\n\t\t$textdomain = $this->get('TextDomain');\n\t\tif ( ! $textdomain ) {\n\t\t\t$this->textdomain_loaded = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tif ( is_textdomain_loaded( $textdomain ) ) {\n\t\t\t$this->textdomain_loaded = true;\n\t\t\treturn true;\n\t\t}\n\n\t\t$path = $this->get_stylesheet_directory();\n\t\tif ( $domainpath = $this->get('DomainPath') )\n\t\t\t$path .= $domainpath;\n\t\telse\n\t\t\t$path .= '/languages';\n\n\t\t$this->textdomain_loaded = load_theme_textdomain( $textdomain, $path );\n\t\treturn $this->textdomain_loaded;\n\t}\n\n\t/**\n\t * Whether the theme is allowed (multisite only).\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param string $check Optional. Whether to check only the 'network'-wide settings, the 'site'\n\t * \tsettings, or 'both'. Defaults to 'both'.\n\t * @param int $blog_id Optional. Ignored if only network-wide settings are checked. Defaults to current blog.\n\t * @return bool Whether the theme is allowed for the network. Returns true in single-site.\n\t */\n\tpublic function is_allowed( $check = 'both', $blog_id = null ) {\n\t\tif ( ! is_multisite() )\n\t\t\treturn true;\n\n\t\tif ( 'both' == $check || 'network' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_network();\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\tif ( 'both' == $check || 'site' == $check ) {\n\t\t\t$allowed = self::get_allowed_on_site( $blog_id );\n\t\t\tif ( ! empty( $allowed[ $this->get_stylesheet() ] ) )\n\t\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site or network.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param int $blog_id Optional. Defaults to current blog.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed( $blog_id = null ) {\n\t\t$network = (array) apply_filters( 'allowed_themes', self::get_allowed_on_network() );\n\t\treturn $network + self::get_allowed_on_site( $blog_id );\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the network.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_network() {\n\t\tstatic $allowed_themes;\n\t\tif ( ! isset( $allowed_themes ) )\n\t\t\t$allowed_themes = (array) get_site_option( 'allowedthemes' );\n\t\treturn $allowed_themes;\n\t}\n\n\t/**\n\t * Returns array of stylesheet names of themes allowed on the site.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t *\n\t * @param int $blog_id Optional. Defaults to current blog.\n\t * @return array Array of stylesheet names.\n\t */\n\tpublic static function get_allowed_on_site( $blog_id = null ) {\n\t\tstatic $allowed_themes = array();\n\n\t\tif ( ! $blog_id || ! is_multisite() )\n\t\t\t$blog_id = get_current_blog_id();\n\n\t\tif ( isset( $allowed_themes[ $blog_id ] ) )\n\t\t\treturn $allowed_themes[ $blog_id ];\n\n\t\t$current = $blog_id == get_current_blog_id();\n\n\t\tif ( $current ) {\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t} else {\n\t\t\tswitch_to_blog( $blog_id );\n\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowedthemes' );\n\t\t\trestore_current_blog();\n\t\t}\n\n\t\t// This is all super old MU back compat joy.\n\t\t// 'allowedthemes' keys things by stylesheet. 'allowed_themes' keyed things by name.\n\t\tif ( false === $allowed_themes[ $blog_id ] ) {\n\t\t\tif ( $current ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t} else {\n\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t$allowed_themes[ $blog_id ] = get_option( 'allowed_themes' );\n\t\t\t\trestore_current_blog();\n\t\t\t}\n\n\t\t\tif ( ! is_array( $allowed_themes[ $blog_id ] ) || empty( $allowed_themes[ $blog_id ] ) ) {\n\t\t\t\t$allowed_themes[ $blog_id ] = array();\n\t\t\t} else {\n\t\t\t\t$converted = array();\n\t\t\t\t$themes = wp_get_themes();\n\t\t\t\tforeach ( $themes as $stylesheet => $theme_data ) {\n\t\t\t\t\tif ( isset( $allowed_themes[ $blog_id ][ $theme_data->get('Name') ] ) )\n\t\t\t\t\t\t$converted[ $stylesheet ] = true;\n\t\t\t\t}\n\t\t\t\t$allowed_themes[ $blog_id ] = $converted;\n\t\t\t}\n\t\t\t// Set the option so we never have to go through this pain again.\n\t\t\tif ( is_admin() && $allowed_themes[ $blog_id ] ) {\n\t\t\t\tif ( $current ) {\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t} else {\n\t\t\t\t\tswitch_to_blog( $blog_id );\n\t\t\t\t\tupdate_option( 'allowedthemes', $allowed_themes[ $blog_id ] );\n\t\t\t\t\tdelete_option( 'allowed_themes' );\n\t\t\t\t\trestore_current_blog();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn (array) $allowed_themes[ $blog_id ];\n\t}\n\n\t/**\n\t * Sort themes by name.\n\t *\n\t * @since 3.4.0\n\t * @access public\n\t */\n\tpublic static function sort_by_name( &$themes ) {\n\t\tif ( 0 === strpos( get_locale(), 'en_' ) ) {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort' ) );\n\t\t} else {\n\t\t\tuasort( $themes, array( 'WP_Theme', '_name_sort_i18n' ) );\n\t\t}\n\t}\n\n\t/**\n\t * Callback function for usort() to naturally sort themes by name.\n\t *\n\t * Accesses the Name header directly from the class for maximum speed.\n\t * Would choke on HTML but we don't care enough to slow it down with strip_tags().\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t */\n\tprivate static function _name_sort( $a, $b ) {\n\t\treturn strnatcasecmp( $a->headers['Name'], $b->headers['Name'] );\n\t}\n\n\t/**\n\t * Name sort (with translation).\n\t *\n\t * @since 3.4.0\n\t * @access private\n\t */\n\tprivate static function _name_sort_i18n( $a, $b ) {\n\t\t// Don't mark up; Do translate.\n\t\treturn strnatcasecmp( $a->display( 'Name', false, true ), $b->display( 'Name', false, true ) );\n\t}\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":38257}]],"length":38257}
