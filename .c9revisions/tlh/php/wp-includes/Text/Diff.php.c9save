{"ts":1381265308020,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php\n/**\n * General API for generating and formatting diffs - the differences between\n * two sequences of strings.\n *\n * The original PHP version of this code was written by Geoffrey T. Dairiki\n * <dairiki@dairiki.org>, and is used/adapted with his permission.\n *\n * Copyright 2004 Geoffrey T. Dairiki <dairiki@dairiki.org>\n * Copyright 2004-2010 The Horde Project (http://www.horde.org/)\n *\n * See the enclosed file COPYING for license information (LGPL). If you did\n * not receive this file, see http://opensource.org/licenses/lgpl-license.php.\n *\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n */\nclass Text_Diff {\n\n    /**\n     * Array of changes.\n     *\n     * @var array\n     */\n    var $_edits;\n\n    /**\n     * Computes diffs between sequences of strings.\n     *\n     * @param string $engine     Name of the diffing engine to use.  'auto'\n     *                           will automatically select the best.\n     * @param array $params      Parameters to pass to the diffing engine.\n     *                           Normally an array of two arrays, each\n     *                           containing the lines from a file.\n     */\n    function Text_Diff($engine, $params)\n    {\n        // Backward compatibility workaround.\n        if (!is_string($engine)) {\n            $params = array($engine, $params);\n            $engine = 'auto';\n        }\n\n        if ($engine == 'auto') {\n            $engine = extension_loaded('xdiff') ? 'xdiff' : 'native';\n        } else {\n            $engine = basename($engine);\n        }\n\n        // WP #7391\n        require_once dirname(__FILE__).'/Diff/Engine/' . $engine . '.php';\n        $class = 'Text_Diff_Engine_' . $engine;\n        $diff_engine = new $class();\n\n        $this->_edits = call_user_func_array(array($diff_engine, 'diff'), $params);\n    }\n\n    /**\n     * Returns the array of differences.\n     */\n    function getDiff()\n    {\n        return $this->_edits;\n    }\n\n    /**\n     * returns the number of new (added) lines in a given diff.\n     *\n     * @since Text_Diff 1.1.0\n     *\n     * @return integer The number of new lines\n     */\n    function countAddedLines()\n    {\n        $count = 0;\n        foreach ($this->_edits as $edit) {\n            if (is_a($edit, 'Text_Diff_Op_add') ||\n                is_a($edit, 'Text_Diff_Op_change')) {\n                $count += $edit->nfinal();\n            }\n        }\n        return $count;\n    }\n\n    /**\n     * Returns the number of deleted (removed) lines in a given diff.\n     *\n     * @since Text_Diff 1.1.0\n     *\n     * @return integer The number of deleted lines\n     */\n    function countDeletedLines()\n    {\n        $count = 0;\n        foreach ($this->_edits as $edit) {\n            if (is_a($edit, 'Text_Diff_Op_delete') ||\n                is_a($edit, 'Text_Diff_Op_change')) {\n                $count += $edit->norig();\n            }\n        }\n        return $count;\n    }\n\n    /**\n     * Computes a reversed diff.\n     *\n     * Example:\n     * <code>\n     * $diff = new Text_Diff($lines1, $lines2);\n     * $rev = $diff->reverse();\n     * </code>\n     *\n     * @return Text_Diff  A Diff object representing the inverse of the\n     *                    original diff.  Note that we purposely don't return a\n     *                    reference here, since this essentially is a clone()\n     *                    method.\n     */\n    function reverse()\n    {\n        if (version_compare(zend_version(), '2', '>')) {\n            $rev = clone($this);\n        } else {\n            $rev = $this;\n        }\n        $rev->_edits = array();\n        foreach ($this->_edits as $edit) {\n            $rev->_edits[] = $edit->reverse();\n        }\n        return $rev;\n    }\n\n    /**\n     * Checks for an empty diff.\n     *\n     * @return boolean  True if two sequences were identical.\n     */\n    function isEmpty()\n    {\n        foreach ($this->_edits as $edit) {\n            if (!is_a($edit, 'Text_Diff_Op_copy')) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Computes the length of the Longest Common Subsequence (LCS).\n     *\n     * This is mostly for diagnostic purposes.\n     *\n     * @return integer  The length of the LCS.\n     */\n    function lcs()\n    {\n        $lcs = 0;\n        foreach ($this->_edits as $edit) {\n            if (is_a($edit, 'Text_Diff_Op_copy')) {\n                $lcs += count($edit->orig);\n            }\n        }\n        return $lcs;\n    }\n\n    /**\n     * Gets the original set of lines.\n     *\n     * This reconstructs the $from_lines parameter passed to the constructor.\n     *\n     * @return array  The original sequence of strings.\n     */\n    function getOriginal()\n    {\n        $lines = array();\n        foreach ($this->_edits as $edit) {\n            if ($edit->orig) {\n                array_splice($lines, count($lines), 0, $edit->orig);\n            }\n        }\n        return $lines;\n    }\n\n    /**\n     * Gets the final set of lines.\n     *\n     * This reconstructs the $to_lines parameter passed to the constructor.\n     *\n     * @return array  The sequence of strings.\n     */\n    function getFinal()\n    {\n        $lines = array();\n        foreach ($this->_edits as $edit) {\n            if ($edit->final) {\n                array_splice($lines, count($lines), 0, $edit->final);\n            }\n        }\n        return $lines;\n    }\n\n    /**\n     * Removes trailing newlines from a line of text. This is meant to be used\n     * with array_walk().\n     *\n     * @param string $line  The line to trim.\n     * @param integer $key  The index of the line in the array. Not used.\n     */\n    static function trimNewlines(&$line, $key)\n    {\n        $line = str_replace(array(\"\\n\", \"\\r\"), '', $line);\n    }\n\n    /**\n     * Determines the location of the system temporary directory.\n     *\n     * @static\n     *\n     * @access protected\n     *\n     * @return string  A directory name which can be used for temp files.\n     *                 Returns false if one could not be found.\n     */\n    function _getTempDir()\n    {\n        $tmp_locations = array('/tmp', '/var/tmp', 'c:\\WUTemp', 'c:\\temp',\n                               'c:\\windows\\temp', 'c:\\winnt\\temp');\n\n        /* Try PHP's upload_tmp_dir directive. */\n        $tmp = ini_get('upload_tmp_dir');\n\n        /* Otherwise, try to determine the TMPDIR environment variable. */\n        if (!strlen($tmp)) {\n            $tmp = getenv('TMPDIR');\n        }\n\n        /* If we still cannot determine a value, then cycle through a list of\n         * preset possibilities. */\n        while (!strlen($tmp) && count($tmp_locations)) {\n            $tmp_check = array_shift($tmp_locations);\n            if (@is_dir($tmp_check)) {\n                $tmp = $tmp_check;\n            }\n        }\n\n        /* If it is still empty, we have failed, so return false; otherwise\n         * return the directory determined. */\n        return strlen($tmp) ? $tmp : false;\n    }\n\n    /**\n     * Checks a diff for validity.\n     *\n     * This is here only for debugging purposes.\n     */\n    function _check($from_lines, $to_lines)\n    {\n        if (serialize($from_lines) != serialize($this->getOriginal())) {\n            trigger_error(\"Reconstructed original doesn't match\", E_USER_ERROR);\n        }\n        if (serialize($to_lines) != serialize($this->getFinal())) {\n            trigger_error(\"Reconstructed final doesn't match\", E_USER_ERROR);\n        }\n\n        $rev = $this->reverse();\n        if (serialize($to_lines) != serialize($rev->getOriginal())) {\n            trigger_error(\"Reversed original doesn't match\", E_USER_ERROR);\n        }\n        if (serialize($from_lines) != serialize($rev->getFinal())) {\n            trigger_error(\"Reversed final doesn't match\", E_USER_ERROR);\n        }\n\n        $prevtype = null;\n        foreach ($this->_edits as $edit) {\n            if ($prevtype == get_class($edit)) {\n                trigger_error(\"Edit sequence is non-optimal\", E_USER_ERROR);\n            }\n            $prevtype = get_class($edit);\n        }\n\n        return true;\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n */\nclass Text_MappedDiff extends Text_Diff {\n\n    /**\n     * Computes a diff between sequences of strings.\n     *\n     * This can be used to compute things like case-insensitve diffs, or diffs\n     * which ignore changes in white-space.\n     *\n     * @param array $from_lines         An array of strings.\n     * @param array $to_lines           An array of strings.\n     * @param array $mapped_from_lines  This array should have the same size\n     *                                  number of elements as $from_lines.  The\n     *                                  elements in $mapped_from_lines and\n     *                                  $mapped_to_lines are what is actually\n     *                                  compared when computing the diff.\n     * @param array $mapped_to_lines    This array should have the same number\n     *                                  of elements as $to_lines.\n     */\n    function Text_MappedDiff($from_lines, $to_lines,\n                             $mapped_from_lines, $mapped_to_lines)\n    {\n        assert(count($from_lines) == count($mapped_from_lines));\n        assert(count($to_lines) == count($mapped_to_lines));\n\n        parent::Text_Diff($mapped_from_lines, $mapped_to_lines);\n\n        $xi = $yi = 0;\n        for ($i = 0; $i < count($this->_edits); $i++) {\n            $orig = &$this->_edits[$i]->orig;\n            if (is_array($orig)) {\n                $orig = array_slice($from_lines, $xi, count($orig));\n                $xi += count($orig);\n            }\n\n            $final = &$this->_edits[$i]->final;\n            if (is_array($final)) {\n                $final = array_slice($to_lines, $yi, count($final));\n                $yi += count($final);\n            }\n        }\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n *\n * @access private\n */\nclass Text_Diff_Op {\n\n    var $orig;\n    var $final;\n\n    function &reverse()\n    {\n        trigger_error('Abstract method', E_USER_ERROR);\n    }\n\n    function norig()\n    {\n        return $this->orig ? count($this->orig) : 0;\n    }\n\n    function nfinal()\n    {\n        return $this->final ? count($this->final) : 0;\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n *\n * @access private\n */\nclass Text_Diff_Op_copy extends Text_Diff_Op {\n\n    function Text_Diff_Op_copy($orig, $final = false)\n    {\n        if (!is_array($final)) {\n            $final = $orig;\n        }\n        $this->orig = $orig;\n        $this->final = $final;\n    }\n\n    function &reverse()\n    {\n        $reverse = new Text_Diff_Op_copy($this->final, $this->orig);\n        return $reverse;\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n *\n * @access private\n */\nclass Text_Diff_Op_delete extends Text_Diff_Op {\n\n    function Text_Diff_Op_delete($lines)\n    {\n        $this->orig = $lines;\n        $this->final = false;\n    }\n\n    function &reverse()\n    {\n        $reverse = new Text_Diff_Op_add($this->orig);\n        return $reverse;\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n *\n * @access private\n */\nclass Text_Diff_Op_add extends Text_Diff_Op {\n\n    function Text_Diff_Op_add($lines)\n    {\n        $this->final = $lines;\n        $this->orig = false;\n    }\n\n    function &reverse()\n    {\n        $reverse = new Text_Diff_Op_delete($this->final);\n        return $reverse;\n    }\n\n}\n\n/**\n * @package Text_Diff\n * @author  Geoffrey T. Dairiki <dairiki@dairiki.org>\n *\n * @access private\n */\nclass Text_Diff_Op_change extends Text_Diff_Op {\n\n    function Text_Diff_Op_change($orig, $final)\n    {\n        $this->orig = $orig;\n        $this->final = $final;\n    }\n\n    function &reverse()\n    {\n        $reverse = new Text_Diff_Op_change($this->final, $this->orig);\n        return $reverse;\n    }\n\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":11945}]],"length":11945}
